<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SetDatabase.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">HappyShop</a> &gt; <a href="index.source.html" class="el_package">ci553.happyshop.systemSetup</a> &gt; <span class="el_source">SetDatabase.java</span></div><h1>SetDatabase.java</h1><pre class="source lang-java linenums">package ci553.happyshop.systemSetup;

import ci553.happyshop.storageAccess.DatabaseRWFactory;
import ci553.happyshop.utility.StorageLocation;

import java.io.IOException;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.sql.*;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * The setDB class is responsible for resetting the database when the system is first initialized.
 * This class performs operations that delete and recreate the database tables, as well as insert
 * default values for a fresh start. Ensuring that everything is properly set up for the fresh database state
 *
 * WARNING: This class should only be used once when starting the system for the first time. It
 * will wipe all current data in the database and replace it with a fresh, predefined structure and data.
 *
 * Key operations:
 * 1. Deletes all existing tables in the database.
 * 2. Recreates the database tables based on the initial schema.
 * 3. Inserts default values into the newly created tables.
 * 4. Deletes all existing image files from the working image folder (images/).
 * 5. Copies all image files from the backup folder (images_resetDB/) into the working image folder.
 */

<span class="nc" id="L29">public class SetDatabase {</span>

    //Use the shared database URL from the factory, appending `;create=true` to create the database if it doesn't exist
<span class="nc" id="L32">    private static final String dbURL = DatabaseRWFactory.dbURL + &quot;;create=true&quot;;</span>
                                  //the value is &quot;jdbc:derby:happyShopDB;create=true&quot;

<span class="nc" id="L35">    private static Path imageWorkingFolderPath = StorageLocation.imageFolderPath;</span>
<span class="nc" id="L36">    private static Path imageBackupFolderPath = StorageLocation.imageResetFolderPath;</span>

<span class="nc" id="L38">    private String[] tables = {&quot;ProductTable&quot;};</span>
    // Currently only &quot;ProductTable&quot; exists, but using an array allows easy expansion
    // if more tables need to be processed in the future without changing the logic structure.

<span class="nc" id="L42">    private static final Lock lock = new ReentrantLock();    // Create a global lock</span>

    public static void main(String[] args) throws SQLException, IOException {
<span class="nc" id="L45">        SetDatabase setDB = new SetDatabase();</span>
<span class="nc" id="L46">        setDB.clearTables(); // clear all tables in the tables array from database if they are existing</span>
<span class="nc" id="L47">        setDB.initializeTable();//create and initialize databse and tables</span>
<span class="nc" id="L48">        setDB.queryTableAfterInitilization();</span>
<span class="nc" id="L49">        deleteFilesInFolder(imageWorkingFolderPath);</span>
<span class="nc" id="L50">        copyFolderContents(imageBackupFolderPath, imageWorkingFolderPath);</span>

<span class="nc" id="L52">    }</span>

    //Deletes all existing tables in the database.
    private void clearTables() throws SQLException {
<span class="nc" id="L56">        lock.lock();  // ðŸ”’ Lock first</span>
<span class="nc" id="L57">        try (Connection con = DriverManager.getConnection(dbURL);</span>
<span class="nc" id="L58">             Statement statement = con.createStatement()) {</span>
<span class="nc" id="L59">            System.out.println(&quot;Database happyShopDB is connected successfully!&quot;);</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">            for (String table : tables) {</span>
                try {
                    // Try to drop table directly
<span class="nc" id="L63">                    statement.executeUpdate(&quot;DROP TABLE &quot; + table.toUpperCase());</span>
<span class="nc" id="L64">                    System.out.println(&quot;Dropped table: &quot; + table);</span>
<span class="nc" id="L65">                } catch (SQLException e) {</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">                    if (&quot;42Y55&quot;.equals(e.getSQLState())) {  // 42Y55 = Table does not exist</span>
<span class="nc" id="L67">                        System.out.println(&quot;Table &quot; + table + &quot; does not exist. Skipping...&quot;);</span>
                    }
<span class="nc" id="L69">                }</span>
            }
        }
        finally {
<span class="nc" id="L73">            lock.unlock();  // ðŸ”“ Always unlock in finally block</span>
        }
<span class="nc" id="L75">    }</span>
    //Recreates the database tables Inserts default values into the newly created tables.
    private void initializeTable() throws SQLException {
<span class="nc" id="L78">        lock.lock(); // Lock to ensure thread safety</span>

        // Table creation and insert statements
<span class="nc" id="L81">        String[] iniTableSQL = {</span>
                // Create ProductTable
                &quot;CREATE TABLE ProductTable(&quot; +
                        &quot;productID CHAR(4) PRIMARY KEY,&quot; +
                        &quot;description VARCHAR(100),&quot; +
                        &quot;unitPrice DOUBLE,&quot; +
                        &quot;image VARCHAR(100),&quot; +
                        &quot;inStock INT,&quot; +
                        &quot;CHECK (inStock &gt;= 0)&quot; +
                        &quot;)&quot;,

                // Insert data into ProductTable - Default products that will always be available
                &quot;INSERT INTO ProductTable VALUES('0001', '40 inch TV', 269.00,'0001.jpg',100)&quot;,
                &quot;INSERT INTO ProductTable VALUES('0002', 'DAB Radio', 29.99, '0002.jpg',100)&quot;,
                &quot;INSERT INTO ProductTable VALUES('0003', 'Toaster', 19.99, '0003.jpg',100)&quot;,
                &quot;INSERT INTO ProductTable VALUES('0004', 'Watch', 29.99, '0004.jpg',100)&quot;,
                &quot;INSERT INTO ProductTable VALUES('0005', 'Digital Camera', 89.99, '0005.jpg',100)&quot;,
                &quot;INSERT INTO ProductTable VALUES('0006', 'MP3 player', 7.99, '0006.jpg',100)&quot;,
                &quot;INSERT INTO ProductTable VALUES('0007', 'USB drive', 6.99, '0007.jpg',100)&quot;,
                &quot;INSERT INTO ProductTable VALUES('0008', 'USB2 drive', 7.99, '0008.jpg',100)&quot;,
                &quot;INSERT INTO ProductTable VALUES('0009', 'USB3 drive', 8.99, '0009.jpg',100)&quot;,
                &quot;INSERT INTO ProductTable VALUES('0010', 'USB4 drive', 9.99, '0010.jpg',100)&quot;,
                &quot;INSERT INTO ProductTable VALUES('0011', 'USB5 drive', 10.99, '0011.jpg',100)&quot;,
                &quot;INSERT INTO ProductTable VALUES('0012', 'USB6 drive', 10.99, '0012.jpg',100)&quot;,
                &quot;INSERT INTO ProductTable VALUES('0013', 'Laptop', 599.99, '0013.jpg',50)&quot;,
                &quot;INSERT INTO ProductTable VALUES('0014', 'Smartphone', 399.99, '0014.jpg',75)&quot;,
                &quot;INSERT INTO ProductTable VALUES('0015', 'Headphones', 49.99, '0015.jpg',120)&quot;,
                &quot;INSERT INTO ProductTable VALUES('0016', 'Tablet', 299.99, '0016.jpg',60)&quot;,
                &quot;INSERT INTO ProductTable VALUES('0017', 'Keyboard', 29.99, '0017.jpg',150)&quot;,
                &quot;INSERT INTO ProductTable VALUES('0018', 'Mouse', 19.99, '0018.jpg',200)&quot;,
                &quot;INSERT INTO ProductTable VALUES('0019', 'Monitor', 199.99, '0019.jpg',40)&quot;,
                &quot;INSERT INTO ProductTable VALUES('0020', 'Speaker', 79.99, '0020.jpg',80)&quot;,
        };

<span class="nc" id="L115">        try (Connection connection = DriverManager.getConnection(dbURL)) {</span>
<span class="nc" id="L116">            System.out.println(&quot;Database happyShopDB is created successfully!&quot;);</span>
<span class="nc" id="L117">            connection.setAutoCommit(false); // Disable auto-commit for the batch</span>

<span class="nc" id="L119">            try (Statement statement = connection.createStatement()) {</span>
                // First, create the table (DDL) - Execute this one separately from DML
<span class="nc" id="L121">                statement.executeUpdate(iniTableSQL[0]);  // Execute Create Table SQL</span>

                // Prepare and execute the insert operations (DML)
<span class="nc bnc" id="L124" title="All 2 branches missed.">                for (int i = 1; i &lt; iniTableSQL.length; i++) {</span>
<span class="nc" id="L125">                    statement.addBatch(iniTableSQL[i]);  // Add insert queries to batch</span>
                }

                // Execute all the insert statements in the batch
<span class="nc" id="L129">                statement.executeBatch();</span>
<span class="nc" id="L130">                connection.commit(); // Commit the transaction if everything was successful</span>

<span class="nc" id="L132">                System.out.println(&quot;Table and data initialized successfully.&quot;);</span>

<span class="nc" id="L134">            } catch (SQLException e) {</span>
<span class="nc" id="L135">                connection.rollback(); // Rollback the transaction in case of an error</span>
<span class="nc" id="L136">                System.err.println(&quot;Transaction rolled back due to an error!&quot;);</span>
<span class="nc" id="L137">                e.printStackTrace();</span>
<span class="nc" id="L138">            }</span>
        } finally {
<span class="nc" id="L140">            lock.unlock(); // Ensure the lock is released after the operation</span>
        }
<span class="nc" id="L142">    }</span>

    private void queryTableAfterInitilization() throws SQLException {
<span class="nc" id="L145">        lock.lock();</span>
        //Query ProductTable
<span class="nc" id="L147">        String sqlQuery = &quot;SELECT * FROM ProductTable&quot;;</span>

<span class="nc" id="L149">        System.out.println(&quot;-------------Product Information Below -----------------&quot;);</span>
<span class="nc" id="L150">        String title = String.format(&quot;%-12s %-20s %-10s %-10s %s&quot;,</span>
                &quot;productID&quot;,
                &quot;description&quot;,
                &quot;unitPrice&quot;,
                &quot;inStock&quot;,
                &quot;image&quot;);
<span class="nc" id="L156">        System.out.println(title);  // Print formatted output</span>

<span class="nc" id="L158">        try (Connection connection = DriverManager.getConnection(dbURL);</span>
<span class="nc" id="L159">             Statement stat = connection.createStatement()){</span>
<span class="nc" id="L160">            ResultSet resultSet = stat.executeQuery(sqlQuery);</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">            while (resultSet.next()) {</span>
<span class="nc" id="L162">                String productID = resultSet.getString(&quot;productID&quot;);</span>
<span class="nc" id="L163">                String description = resultSet.getString(&quot;description&quot;);</span>
<span class="nc" id="L164">                double unitPrice = resultSet.getDouble(&quot;unitPrice&quot;);</span>
<span class="nc" id="L165">                String image = resultSet.getString(&quot;image&quot;);</span>
<span class="nc" id="L166">                int inStock = resultSet.getInt(&quot;inStock&quot;);</span>
<span class="nc" id="L167">                String record = String.format(&quot;%-12s %-20s %-10.2f %-10d %s&quot;, productID, description, unitPrice, inStock, image);</span>
<span class="nc" id="L168">                System.out.println(record);  // Print formatted output</span>
<span class="nc" id="L169">            }</span>
        }
        finally {
<span class="nc" id="L172">            lock.unlock();</span>
        }
<span class="nc" id="L174">    }</span>

    // Recursively deletes all files in a folder
    public static void deleteFilesInFolder(Path folder) throws IOException {
<span class="nc bnc" id="L178" title="All 2 branches missed.">        if (Files.exists(folder)) {</span>
<span class="nc" id="L179">            lock.lock();</span>
            try {
<span class="nc" id="L181">                Files.walkFileTree(folder, new SimpleFileVisitor&lt;&gt;() {</span>
                    @Override
                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
<span class="nc" id="L184">                        Files.delete(file); //delete individual files</span>
<span class="nc" id="L185">                        return FileVisitResult.CONTINUE;</span>
                    }
                });
<span class="nc" id="L188">                System.out.println(&quot;Deleted files in folder: &quot; + folder);</span>
            } finally {
<span class="nc" id="L190">                lock.unlock();</span>
<span class="nc" id="L191">            }</span>
        }
        else {
<span class="nc" id="L194">            System.out.println(&quot;Folder &quot; + folder + &quot; does not exist&quot;);</span>
        }
<span class="nc" id="L196">    }</span>


    /**
     * The method Files.walkFileTree(Path, FileVisitor) traverses (or &quot;walks through&quot;) a directory and all of its subdirectories.
     * It accepts two arguments:
     * 1. directory (Path or folder) path from which the traversal begins (the starting point of the walk).
     * 2. A FileVisitor object that defines the actions to be performed when a file or directory is visited.
     *    The visitor is an instance of the FileVisitor interface, which provides methods for handling different events during the traversal.
     *
     * Here, we use an anonymous class to create the second argument - the instance (object) â€“
     * An anonymous class allows you to extend a superclass (or implement an interface) and instantiate it in a single, concise step,
     * without needing to define a separate named class. It combines both class extension and object creation into one operation,
     * typically used when you need a one-off implementation of a class or interface.
     * (Note: the object is the anonymous class's)
     *
     * We did not use Files.walkFileTree(folder, new FileVisitor&lt;&gt;()) because FileVisitor is an interface, and we would need to implement
     * all of its methods ourselves. Instead, we use Files.walkFileTree(folder, new SimpleFileVisitor&lt;&gt;()) because:
     * - SimpleFileVisitor&lt;&gt; is an abstract class that implements the FileVisitor interface with default method implementations.
     * - We only need to override the methods (visitFile, postVisitDirectory) that we're interested in, which simplifies our code.
     */

    // Copies all files from source folder to destination folder
    public static void copyFolderContents(Path source, Path destination) throws IOException {
<span class="nc" id="L220">        lock.lock();</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">        if (!Files.exists(source)) {</span>
<span class="nc" id="L222">            throw new IOException(&quot;Source folder does not exist: &quot; + source);</span>
        }

        // Create destination folder if it doesn't exist
<span class="nc bnc" id="L226" title="All 2 branches missed.">        if (!Files.exists(destination)) {</span>
<span class="nc" id="L227">            Files.createDirectories(destination);</span>
        }

        // Copy files from source folder to destination folder
        //Files.newDirectoryStream(source): list all entries (files and folders) directly in the source directory
<span class="nc" id="L232">        try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(source)) {</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">            for (Path file : stream) {</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">                if (Files.isRegularFile(file)) {</span>
<span class="nc" id="L235">                    Path targetFile = destination.resolve(file.getFileName());</span>
<span class="nc" id="L236">                    Files.copy(file, targetFile, StandardCopyOption.REPLACE_EXISTING);</span>
                }
<span class="nc" id="L238">            }</span>
        }
        finally {
<span class="nc" id="L241">            lock.unlock();</span>
        }
<span class="nc" id="L243">        System.out.println(&quot;Copied files from: &quot; + source + &quot; â†’ &quot; + destination);</span>
<span class="nc" id="L244">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>